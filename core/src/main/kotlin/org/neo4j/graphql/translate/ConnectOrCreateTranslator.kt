package org.neo4j.graphql.translate

import org.neo4j.cypherdsl.core.*
import org.neo4j.cypherdsl.core.StatementBuilder.*
import org.neo4j.graphql.*
import org.neo4j.graphql.domain.directives.AuthDirective
import org.neo4j.graphql.domain.dto.ConnectOrCreateInput
import org.neo4j.graphql.domain.fields.RelationField

fun createConnectOrCreate(
    inputs: List<ConnectOrCreateInput>,
    varName: String,
    parentVar: Node,
    relationField: RelationField,
    refNode: org.neo4j.graphql.domain.Node,
    withVars: List<SymbolicName>,
    exposeWith: ExposesWith,
    context: QueryContext?,
    schemaConfig: SchemaConfig,
): ExposesWith {
    var result: ExposesMerge = Cypher.with(withVars)

    inputs.forEachIndexed { index, input ->
        val node = refNode.asCypherNode(context, schemaConfig.namingStrategy.resolveName(varName, index))

        val authCondition = AuthTranslator(
            schemaConfig,
            context,
            allow = AuthTranslator.AuthOptions(
                node,
                refNode,
                schemaConfig.namingStrategy.resolveName(node, index, "allow")
            )
        )
            .createAuth(refNode.auth, setOf(AuthDirective.AuthOperation.CONNECT, AuthDirective.AuthOperation.CREATE))

        val onNodeCreationProperties = createSetProperties(
            node,
            input.onCreate?.node,
            Operation.CREATE,
            refNode,
            schemaConfig,
            paramPrefix = schemaConfig.namingStrategy.resolveParameter(node, "on", "create"),
            // include autogenerated fields (e.g. @id) only if field is not included in where
            autoGenerateFieldFilter = { input.where?.node?.containsKey(it) != true }
        )

        val dslRelation = relationField.createDslRelation(
            parentVar, node, schemaConfig.namingStrategy.resolveName(parentVar, "relationship", node)
        )
        val onEdgeCreationProperties = createSetProperties(
            dslRelation,
            input.onCreate?.edge,
            Operation.CREATE,
            relationField.properties,
            schemaConfig,
            paramPrefix = schemaConfig.namingStrategy.resolveParameter(dslRelation, "on", "create"),
            // include autogenerated fields (e.g. @id) only if field is not included in where
            autoGenerateFieldFilter = { input.where?.node?.containsKey(it) != true }
        )

        val nodeWithProps = input.where?.node
            ?.map { (k, v) ->
                k.dbPropertyName to Cypher.parameter(schemaConfig.namingStrategy.resolveParameter(node, "node", k), v)
            }
            ?.takeIf { it.isNotEmpty() }
            ?.let { node.withProperties(it.toMap()) }
            ?: node

       result = (authCondition?.let { (result as ExposesSubqueryCall).apocValidate(it, Constants.AUTH_FORBIDDEN_ERROR) } ?: result)
            .merge(nodeWithProps)
            .let {
                if (onNodeCreationProperties.isNotEmpty()) it.onCreate().set(onNodeCreationProperties) else it
            }
            .merge(dslRelation)
            .let {
                if (onEdgeCreationProperties.isNotEmpty()) it.onCreate().set(onEdgeCreationProperties) else it
            }
    }

    return exposeWith
        .with(withVars)
        .call((result as ExposesReturning).returning(Functions.count(Cypher.asterisk())).build())
}
