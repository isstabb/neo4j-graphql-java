package org.neo4j.graphql.translate

import org.neo4j.cypherdsl.core.*
import org.neo4j.cypherdsl.core.StatementBuilder.ExposesWith
import org.neo4j.graphql.*
import org.neo4j.graphql.domain.directives.AuthDirective
import org.neo4j.graphql.domain.fields.RelationField
import org.neo4j.graphql.domain.inputs.connect_or_create.ConnectOrCreateFieldInput
import org.neo4j.graphql.handler.utils.ChainString

fun createConnectOrCreate(
    inputs: List<ConnectOrCreateFieldInput.NodeConnectOrCreateFieldInput>,
    varName: ChainString,
    parentVar: Node,
    relationField: RelationField,
    refNode: org.neo4j.graphql.domain.Node,
    withVars: List<SymbolicName>,
    exposeWith: ExposesWith,
    context: QueryContext,
    schemaConfig: SchemaConfig,
): ExposesWith {
    var result: ExposesWith = Cypher.with(withVars)
    inputs.forEachIndexed { index, input ->
        val subqueryBaseName = varName.extend(index)

        val node = refNode.asCypherNode(context, subqueryBaseName)

        result = AuthTranslator(
            schemaConfig, context,
            allow = AuthTranslator.AuthOptions(
                node,
                refNode,
                subqueryBaseName.extend(node, index, "allow")
            )
        )
            .createAuth(refNode.auth, AuthDirective.AuthOperation.CONNECT, AuthDirective.AuthOperation.CREATE)
            ?.let { result.maybeWith(withVars).apocValidate(it, Constants.AUTH_FORBIDDEN_ERROR) }
            ?: result

        val onNodeCreationProperties = createSetProperties(
            node,
            input.onCreate?.node,
            Operation.CREATE,
            refNode,
            schemaConfig,
            paramPrefix = subqueryBaseName.extend("on", "create"),
            // include autogenerated fields (e.g. @id) only if field is not included in where
            autoGenerateFieldFilter = { input.where?.node?.containsKey(it) != true }
        )

        val relName = ChainString(schemaConfig, parentVar, "relationship", node)
        val dslRelation = relationField.createDslRelation(
            parentVar, node, relName
        )
        val onEdgeCreationProperties = createSetProperties(
            dslRelation,
            input.onCreate?.edge,
            Operation.CREATE,
            relationField.properties,
            schemaConfig,
            paramPrefix = relName.extend("on", "create"),
            // include autogenerated fields (e.g. @id) only if field is not included in where
            autoGenerateFieldFilter = { input.where?.node?.containsKey(it) != true }
        )

        val nodeWithProps = input.where?.node
            ?.map { (k, v) ->
                k.dbPropertyName to Cypher.parameter(schemaConfig.namingStrategy.resolveParameter(node, "node", k), v)
            }
            ?.takeIf { it.isNotEmpty() }
            ?.let { node.withProperties(it.toMap()) }
            ?: node


        result = (result as ExposesMerge)
            .merge(nodeWithProps)
            .conditionalBlock(onNodeCreationProperties != null) { it.onCreate().set(onNodeCreationProperties) }
            .merge(dslRelation)
            .conditionalBlock(onEdgeCreationProperties != null) { it.onCreate().set(onEdgeCreationProperties) }
    }

    return exposeWith
        .with(withVars)
        .call(
            (result as ExposesReturning)
                .returning(Functions.count(Cypher.asterisk()))
                .build()
        )
}
