# Instructs neo4j-graphql-java to map a GraphQL field to a Neo4j node or relationship property.
directive @alias(
  #The name of the Neo4j property
  property:String!
) on FIELD_DEFINITION

directive @auth(rules: [AuthRule!]!) on OBJECT | FIELD_DEFINITION

# Instructs neo4j-graphql-java to wrap the property in a coalesce() function during queries, using the single value specified.
directive @coalesce(
  # The value to use in the coalesce() function. Must be a scalar type and must match the type of the field with which this directive decorates.
  value: ScalarType!
) on FIELD_DEFINITION

# Instructs neo4j-graphql-java to run the specified Cypher statement in order to resolve the value of the field to which the directive is applied.
directive @cypher(
  # The Cypher statement to run which returns a value of the same type composition as the field definition on which the directive is applied.
  #
  # Arguments on the field are passed to the Cypher statement and can be used by name.
  # They must not be prefixed by `$` since they are no longer parameters.
  # Just use the same name as the fields' argument.
  # The current node is passed to the statement as `this`.
  # The statement should contain exactly one return expression without any alias.
  # Input types are supported, they appear as `Map` type in your Cypher statement.
  statement: String!

  # # TODO create feature request
  # if true, passes the sole responsibility for the nested query result for the field to your Cypher query.
  # You will have to provide all data/structure required by client queries.
  # Otherwise, we assume if you return object-types that you will return the appropriate nodes from your statement.
  passThrough: Boolean = false
) on FIELD_DEFINITION

# Instructs neo4j-graphql-java to set the specified value as the default value in the CreateInput type for the object type in which this directive is used.
directive @default(
  # The default value to use. Must be a scalar type and must match the type of the field with which this directive decorates.
  value: ScalarType!
) on FIELD_DEFINITION

# Instructs neo4j-graphql-java to exclude the specified operations from query and mutation generation.
# If used without an argument, no queries or mutations will be generated for this type.
directive @exclude(operations: [ExcludeOperation!]! = [CREATE, READ, UPDATE, DELETE]) on OBJECT | INTERFACE

# Informs neo4j-graphql-java that there should be a fulltext index in the database, allows users to search by the index in the generated schema.
directive @fulltext(indexes: [FullTextIndex!]!) on OBJECT

# Indicates that the field is an identifier for the object type. By default; autogenerated, and has a unique node property constraint in the database.
directive @id(autogenerate: Boolean! = true, unique: Boolean! = true) on FIELD_DEFINITION

# Instructs neo4j-graphql-java to completely ignore a field definition, assuming that it will be fully accounted for by custom resolvers.
directive @ignore on FIELD_DEFINITION

# Informs neo4j-graphql-java of node metadata
directive @node(
  # Map the GraphQL type to a custom Neo4j node label
  label: String,

  # Map the GraphQL type to match additional Neo4j node labels
  additionalLabels: [String!],

  #Defines a custom plural for the Node API
  plural: String
) on OBJECT

# TODO
# Instructs neo4j-graphql-java to only expose a field through the Neo4j GraphQL OGM.
directive @private on FIELD_DEFINITION

# Instructs neo4j-graphql-java to only include a field in generated input type for creating, and in the object type within which the directive is applied.
directive @readonly on FIELD_DEFINITION

# Instructs neo4j-graphql-java to treat this field as a relationship. Opens up the ability to create and connect on this field.
directive @relationship(
  type:String!,
  direction: RelationDirection!,
  # The name of the interface containing the properties for this relationship.
  properties: String
) on FIELD_DEFINITION

# TODO is this required?
# Syntactic sugar to help differentiate between interfaces for relationship properties, and otherwise.
directive @relationshipProperties on INTERFACE

# Instructs neo4j-graphql-java to generate timestamps on particular events, which will be available as the value of the specified field.
directive @timestamp(
  # Which events to generate timestamps on. Defaults to both create and update.
  operations: [TimeStampOperation!] = [CREATE, UPDATE]
) on FIELD_DEFINITION

# TODO implement
# Informs neo4j-graphql-java that there should be a uniqueness constraint in the database for the decorated field.
directive @unique(
  # The name which should be used for this constraint. By default; type name, followed by an underscore, followed by the field name.
  constraintName: String
) on FIELD_DEFINITION

# Instructs neo4j-graphql-java to only include a field in the generated input types for the object type within which the directive is applied, but exclude it from the object type itself.
directive @writeonly on FIELD_DEFINITION

scalar Object

scalar ScalarType

enum RelationDirection {
  IN
  OUT
}

input AuthRule {
  operations: [AuthOperation!]
  isAuthenticated: Boolean
  allowUnauthenticated: Boolean
  allow: Object
  bind: Object
  where: Object
  roles: [String!]
  AND: [BaseAuthRule!]
  OR: [BaseAuthRule!]
}

input BaseAuthRule {
  isAuthenticated: Boolean
  allowUnauthenticated: Boolean
  allow: Object
  bind: Object
  where: Object
  roles: [String!]
  AND: [BaseAuthRule!]
  OR: [BaseAuthRule!]
}

input FullTextIndex {
  name: String!
  fields: [String!]!
  defaultThreshold: Int
}

enum AuthOperation {
  CREATE, READ, UPDATE, DELETE, CONNECT, DISCONNECT
}

enum ExcludeOperation {
  CREATE, READ, UPDATE, DELETE
}

enum TimeStampOperation {
  CREATE, UPDATE
}

# TODO renamed to alias
directive @property(name:String) on FIELD_DEFINITION

# TODO create feature request
directive @dynamic(prefix:String = "properties.") on FIELD_DEFINITION
