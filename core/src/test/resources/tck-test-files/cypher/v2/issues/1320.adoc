:toc:

= https://github.com/neo4j/graphql/issues/1320

== Source schema

[source,graphql,schema=true]
----
type Risk {
  code: String!
  ownedBy: Team @relationship(type: "OWNS_RISK", direction: IN)
  mitigationState: [MitigationState]
}

type Team {
  code: String!
  ownsRisks: [Risk!]! @relationship(type: "OWNS_RISK", direction: OUT)
}

enum MitigationState {
  Deferred
  Identified
  Accepted
  Complete
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{}
----
== multiple aggregations in the same query should return the same results as if were written separately

.GraphQL-Query
[source,graphql]
----
query getAggreationOnTeams {
  stats: teams {
    accepted: ownsRisksAggregate(where: {mitigationState_INCLUDES: Accepted}) {
      count
    }
    identified: ownsRisksAggregate(where: {mitigationState_INCLUDES: Identified}) {
      count
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "this_accepted_param0": "Accepted",
  "this_identified_param0": "Identified"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:`Team`)

CALL {
    WITH this
    MATCH (this)-[this_accepted_this0:OWNS_RISK]->(this_accepted_this1:`Risk`)
    WHERE $this_accepted_param0 IN this_accepted_this1.mitigationState
    RETURN count(this) AS this_accepted_var2
}
CALL {
    WITH this
    MATCH (this)-[this_identified_this0:OWNS_RISK]->(this_identified_this1:`Risk`)
    WHERE $this_identified_param0 IN this_identified_this1.mitigationState
    RETURN count(this) AS this_identified_var2
}
RETURN this { accepted: { count: this_accepted_var2 }, identified: { count: this_identified_var2 } } AS this
----

'''

