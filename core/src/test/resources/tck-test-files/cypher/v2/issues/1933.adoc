:toc:

= https://github.com/neo4j/graphql/issues/1933

== Source schema

[source,graphql,schema=true]
----
type Employee {
  employeeId: ID! @id(autogenerate: false)
  firstName: String! @readonly
  lastName: String @readonly
  projects: [Project!]! @relationship(type: "PARTICIPATES", direction: OUT, properties: "EmployeeParticipationProperties")
}

interface EmployeeParticipationProperties @relationshipProperties {
  allocation: Float
}

type Project {
  projectId: ID! @id(autogenerate: false)
  name: String! @readonly
  description: String
  employees: [Employee!]! @relationship(type: "PARTICIPATES", direction: IN, properties: "EmployeeParticipationProperties")
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{}
----
== should compare for LTE allocation in return statement

.GraphQL-Query
[source,graphql]
----
{
  employees(where: {projectsAggregate: {edge: {allocation_LTE: 25}}}) {
    employeeId
    firstName
    lastName
    projectsAggregate {
      count
      edge {
        allocation {
          max
          min
          average
          sum
        }
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : 25
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Employee)
CALL {
	WITH this
	MATCH (this)-[this0:PARTICIPATES]->(this1:Project)
	RETURN any(var2 IN collect(this0.allocation) WHERE var2 <= $param0) AS var3
}
WITH *
WHERE var3 = true
CALL {
	WITH this
	MATCH (this)-[this_projectsAggregate_this0:PARTICIPATES]->(this_projectsAggregate_this1:Project)
	RETURN count(this_projectsAggregate_this1) AS this_projectsAggregate_var2
}
CALL {
	WITH this
	MATCH (this)-[this_projectsAggregate_this0:PARTICIPATES]->(this_projectsAggregate_this1:Project)
	RETURN {
		min: min(this_projectsAggregate_this0.allocation),
		max: max(this_projectsAggregate_this0.allocation),
		average: avg(this_projectsAggregate_this0.allocation),
		sum: sum(this_projectsAggregate_this0.allocation)
	} AS this_projectsAggregate_var3
}
RETURN this {
	.employeeId,
	.firstName,
	.lastName,
	projectsAggregate: {
		count: this_projectsAggregate_var2,
		edge: {
			allocation: this_projectsAggregate_var3
		}
	}
} AS this
----

'''

== should compare for SUM_LTE allocation in return statement rather than the WITH clause

.GraphQL-Query
[source,graphql]
----
{
  employees(where: {projectsAggregate: {edge: {allocation_SUM_LTE: 25}}}) {
    employeeId
    firstName
    lastName
    projectsAggregate {
      count
      edge {
        allocation {
          max
          min
          average
          sum
        }
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : 25
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Employee)
CALL {
	WITH this
	MATCH (this)-[this0:PARTICIPATES]->(this1:Project)
	RETURN sum(this0.allocation) <= $param0 AS var2
}
WITH *
WHERE var2 = true
CALL {
	WITH this
	MATCH (this)-[this_projectsAggregate_this0:PARTICIPATES]->(this_projectsAggregate_this1:Project)
	RETURN count(this_projectsAggregate_this1) AS this_projectsAggregate_var2
}
CALL {
	WITH this
	MATCH (this)-[this_projectsAggregate_this0:PARTICIPATES]->(this_projectsAggregate_this1:Project)
	RETURN {
		min: min(this_projectsAggregate_this0.allocation),
		max: max(this_projectsAggregate_this0.allocation),
		average: avg(this_projectsAggregate_this0.allocation),
		sum: sum(this_projectsAggregate_this0.allocation)
	} AS this_projectsAggregate_var3
}
RETURN this {
	.employeeId,
	.firstName,
	.lastName,
	projectsAggregate: {
		count: this_projectsAggregate_var2,
		edge: {
			allocation: this_projectsAggregate_var3
		}
	}
} AS this
----

'''

