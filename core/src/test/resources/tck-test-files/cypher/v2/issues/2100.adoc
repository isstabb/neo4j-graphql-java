:toc:

= https://github.com/neo4j/graphql/issues/2100

== Source schema

[source,graphql,schema=true]
----
type ServiceLog {
  id: ID
  records: [Record!]! @relationship(type: "HAS_BUSSING", direction: OUT)
}

type BussingRecord implements Record {
  id: ID!
  attendance: Int
  markedAttendance: Boolean! @cypher(statement: """
  MATCH (this)<-[:PRESENT_AT_SERVICE|ABSENT_FROM_SERVICE]-(member:Member)
  RETURN COUNT(member) > 0 AS markedAttendance
  """)
  serviceDate: TimeGraph! @relationship(type: "BUSSED_ON", direction: OUT)
}

interface Church @auth(rules: [{isAuthenticated: true}]) {
  id: ID @id
  name: String!
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
}

type Bacenta implements Church {
  id: ID @id
  name: String!
  serviceLogs: [ServiceLog!]! @relationship(type: "HAS_HISTORY", direction: OUT)
  bussing(limit: Int!): [BussingRecord!]! @cypher(statement: """
  MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(records:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
  WITH DISTINCT records, date LIMIT $limit
  RETURN records ORDER BY date.date DESC
  """)
}

type TimeGraph @auth(rules: [{isAuthenticated: true}]) {
  date: Date
}

interface Record {
  id: ID!
  attendance: Int
  markedAttendance: Boolean! @cypher(statement: """
  MATCH (this)<-[:PRESENT_AT_SERVICE|ABSENT_FROM_SERVICE]-(member:Member)
  RETURN COUNT(member) > 0 AS markedAttendance
  """)
  serviceDate: TimeGraph! @relationship(type: "BUSSED_ON", direction: OUT)
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{}
----
== query nested relations under a root connection field

.GraphQL-Query
[source,graphql]
----
{
  bacentas(where: {id: 1}) {
    id
    name
    bussing(limit: 10) {
      id
      attendance
      markedAttendance
      serviceDate {
        date
        __typename
      }
      __typename
    }
    __typename
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "1",
  "param2": {
    "low": 10,
    "high": 0
  },
  "auth": {
    "isAuthenticated": false,
    "roles": []
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Bacenta)
WHERE (this.id = $param0
	AND apoc.util.validatePredicate(NOT (apoc.util.validatePredicate(NOT ($auth.isAuthenticated = true), '@neo4j/graphql/UNAUTHENTICATED', [0])), '@neo4j/graphql/FORBIDDEN', [0]))
CALL {
	WITH this
	UNWIND apoc.cypher.runFirstColumnMany('MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_BUSSING]->(records:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph)
    WITH DISTINCT records, date LIMIT $limit
    RETURN records ORDER BY date.date DESC', {
		limit: $param2,
		this: this,
		auth: $auth
	}) AS this_bussing
	CALL {
		WITH this_bussing
		UNWIND apoc.cypher.runFirstColumnSingle('MATCH (this)<-[:PRESENT_AT_SERVICE|ABSENT_FROM_SERVICE]-(member:Member)
        RETURN COUNT(member) > 0 AS markedAttendance', {
			this: this_bussing,
			auth: $auth
		}) AS this_bussing_markedAttendance
		RETURN head(collect(this_bussing_markedAttendance)) AS this_bussing_markedAttendance
	}
	CALL {
		WITH this_bussing
		MATCH (this_bussing)-[this0:BUSSED_ON]->(this_bussing_serviceDate:TimeGraph)
		WHERE apoc.util.validatePredicate(NOT (apoc.util.validatePredicate(NOT ($auth.isAuthenticated = true), '@neo4j/graphql/UNAUTHENTICATED', [0])), '@neo4j/graphql/FORBIDDEN', [0])
		WITH this_bussing_serviceDate {
			.date
		} AS this_bussing_serviceDate
		RETURN head(collect(this_bussing_serviceDate)) AS this_bussing_serviceDate
	}
	RETURN collect(this_bussing {
		.id,
		.attendance,
		markedAttendance: this_bussing_markedAttendance,
		serviceDate: this_bussing_serviceDate
	}) AS this_bussing
}
RETURN this {
	.id,
	.name,
	bussing: this_bussing
} AS this
----

'''

