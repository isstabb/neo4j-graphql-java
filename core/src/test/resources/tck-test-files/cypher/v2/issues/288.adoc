:toc:

= #288

== Source schema

[source,graphql,schema=true]
----
type USER {
  USERID: String
  COMPANYID: String
  COMPANY: [COMPANY!]! @relationship(type: "IS_PART_OF", direction: OUT)
}

type COMPANY {
  USERS: [USER!]! @relationship(type: "IS_PART_OF", direction: IN)
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{
  "enableRegex": true
}
----
== Can create a USER and COMPANYID is populated

.GraphQL-Query
[source,graphql]
----
mutation {
  createUSERS(input: {USERID: "userid", COMPANYID: "companyid"}) {
    uSERS {
      USERID
      COMPANYID
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "this0_USERID": "userid",
  "this0_COMPANYID": "companyid"
}
----

.Expected Cypher output
[source,cypher]
----
CALL {
CREATE (this0:USER)
SET this0.USERID = $this0_USERID
SET this0.COMPANYID = $this0_COMPANYID
RETURN this0
}
RETURN 
this0 { .USERID, .COMPANYID } AS this0
----

== Can update a USER and COMPANYID is populated

.GraphQL-Query
[source,graphql]
----
mutation {
  updateUSERS(where: {USERID: "userid"}, update: {COMPANYID: "companyid2"}) {
    uSERS {
      USERID
      COMPANYID
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "this_USERID": "userid",
  "this_update_COMPANYID": "companyid2"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:USER)
WHERE this.USERID = $this_USERID

SET this.COMPANYID = $this_update_COMPANYID

RETURN this { .USERID, .COMPANYID } AS this
----

