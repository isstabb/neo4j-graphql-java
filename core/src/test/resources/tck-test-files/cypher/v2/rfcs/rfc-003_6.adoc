:toc:

= nested mutations

== Source schema

[source,graphql,schema=true]
----
type Address {
  id: ID!
}

type Director {
  id: ID!
  address: Address @relationship(type: "HAS_ADDRESS", direction: OUT)
}

type CoDirector {
  id: ID!
}

type Movie {
  id: ID!
  director: Director @relationship(type: "DIRECTED", direction: IN)
  coDirector: CoDirector @relationship(type: "CO_DIRECTED", direction: IN)
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{}
----
== should add length validation when deleting a node with a non required relationship

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(
    where: {id: "movieId-4"}
    delete: {director: {where: {node: {id: "directorId-3"}}, delete: {address: {where: {node: {id: "some-address"}}}}}}
  ) {
    info {
      nodesCreated
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "this_id": "movieId-4",
  "updateMovies": {
    "args": {
      "delete": {
        "director": {
          "where": {
            "node": {
              "id": "directorId-3"
            }
          },
          "delete": {
            "address": {
              "where": {
                "node": {
                  "id": "some-address"
                }
              }
            }
          }
        }
      }
    }
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
WHERE this.id = $this_id
WITH this
OPTIONAL MATCH (this)<-[this_delete_director0_relationship:DIRECTED]-(this_delete_director0:Director)
WHERE this_delete_director0.id = $updateMovies.args.delete.director.where.node.id
WITH this, this_delete_director0
OPTIONAL MATCH (this_delete_director0)-[this_delete_director0_address0_relationship:HAS_ADDRESS]->(this_delete_director0_address0:Address)
WHERE this_delete_director0_address0.id = $updateMovies.args.delete.director.delete.address.where.node.id
WITH this, this_delete_director0, collect(DISTINCT this_delete_director0_address0) as this_delete_director0_address0_to_delete
FOREACH(x IN this_delete_director0_address0_to_delete | DETACH DELETE x)
WITH this, collect(DISTINCT this_delete_director0) as this_delete_director0_to_delete
FOREACH(x IN this_delete_director0_to_delete | DETACH DELETE x)
WITH this
CALL {
	WITH this
	MATCH (this)<-[this_director_Director_unique:DIRECTED]-(:Director)
	WITH count(this_director_Director_unique) as c
	CALL apoc.util.validate(NOT(c <= 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDMovie.director must be less than or equal to one', [0])
	RETURN c AS this_director_Director_unique_ignored
}
CALL {
	WITH this
	MATCH (this)<-[this_coDirector_CoDirector_unique:CO_DIRECTED]-(:CoDirector)
	WITH count(this_coDirector_CoDirector_unique) as c
	CALL apoc.util.validate(NOT(c <= 1), '@neo4j/graphql/RELATIONSHIP-REQUIREDMovie.coDirector must be less than or equal to one', [0])
	RETURN c AS this_coDirector_CoDirector_unique_ignored
}
RETURN 'Query cannot conclude with CALL'
----

'''

