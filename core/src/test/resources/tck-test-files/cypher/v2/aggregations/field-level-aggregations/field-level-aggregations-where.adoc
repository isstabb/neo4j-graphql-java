:toc:

= Field Level Aggregations Where

== Source schema

[source,graphql,schema=true]
----
type Movie {
  title: String
  actors: [Person!]! @relationship(type: "ACTED_IN", direction: IN)
  directors: [Person!]! @relationship(type: "DIRECTED", direction: IN)
  released: DateTime
}

type Person {
  name: String
  age: Int
  movies: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT)
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{
  "enableRegex": true
}
----
== Count aggregation with colliding filter

.GraphQL-Query
[source,graphql]
----
{
  movies {
    title
    actorsAggregate(where: {name_CONTAINS: "abc"}) {
      count
    }
    directorsAggregate(where: {name_CONTAINS: "abcdefg"}) {
      count
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "abc",
  "param1" : "abcdefg"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
CALL {
	WITH this
	MATCH (person:Person)-[edge:ACTED_IN]->(this)
	WHERE person.name CONTAINS $param0
	RETURN count(person) AS this_actorsAggregate_var0
}
CALL {
	WITH this
	MATCH (person:Person)-[edge:DIRECTED]->(this)
	WHERE person.name CONTAINS $param1
	RETURN count(person) AS this_directorsAggregate_var1
}
RETURN this {
	.title,
	actorsAggregate: {
		count: this_actorsAggregate_var0
	},
	directorsAggregate: {
		count: this_directorsAggregate_var1
	}
} AS this
----

'''

== Count aggregation with number filter

.GraphQL-Query
[source,graphql]
----
{
  movies {
    title
    actorsAggregate(where: {age_GT: 40}) {
      count
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : 40
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Movie)
CALL {
	WITH this
	MATCH (person:Person)-[edge:ACTED_IN]->(this)
	WHERE person.age > $param0
	RETURN count(person) AS this_actorsAggregate_var0
}
RETURN this {
	.title,
	actorsAggregate: {
		count: this_actorsAggregate_var0
	}
} AS this
----

'''

