:toc:

= Node directive with unions

== Source schema

[source,graphql,schema=true]
----
union Search = Movie | Genre

type Genre @node(label: "Category", additionalLabels: ["ExtraLabel1", "ExtraLabel2"]) {
  name: String
}

type Movie @node(label: "Film") {
  title: String
  search: [Search!]! @relationship(type: "SEARCH", direction: OUT)
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{
  "enableRegex": true
}
----
== Read Unions

.GraphQL-Query
[source,graphql]
----
{
  movies(where: {title: "some title"}) {
    search(
      where: {Movie: {title: "The Matrix"}, Genre: {name: "Horror"}}
      options: {offset: 1, limit: 10}
    ) {
      ... on Movie {
        title
      }
      ... on Genre {
        name
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "some title",
  "param1": "Horror",
  "param2": "The Matrix",
  "param3": {
    "low": 1,
    "high": 0
  },
  "param4": {
    "low": 10,
    "high": 0
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:Film)
WHERE this.title = $param0
CALL {
	WITH this
	CALL {
		WITH *
		MATCH (this)-[this0:SEARCH]->(this_search:Category:ExtraLabel1:ExtraLabel2)
		WHERE this_search.name = $param1
		WITH this_search {
			__resolveType: 'Genre',
			.name
		} AS this_search
		RETURN this_search AS this_search UNION
		WITH *
		MATCH (this)-[this1:SEARCH]->(this_search:Film)
		WHERE this_search.title = $param2
		WITH this_search {
			__resolveType: 'Movie',
			.title
		} AS this_search
		RETURN this_search AS this_search
	}
	WITH this_search SKIP $param3 LIMIT $param4
	RETURN collect(this_search) AS this_search
}
RETURN this {
	search: this_search
} AS this
----

'''

