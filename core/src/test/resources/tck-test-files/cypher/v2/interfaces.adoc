:toc:

= Interfaces tests

== Source schema

[source,graphql,schema=true]
----
type SomeNode implements MyInterface {
  id: ID! @id
  other: OtherNode! @relationship(type: "HAS_OTHER_NODES", direction: OUT)
}

type OtherNode {
  id: ID! @id
  interfaceField: MyInterface! @relationship(type: "HAS_INTERFACE_NODES", direction: OUT)
}

interface MyInterface {
  id: ID! @id
}

type MyImplementation implements MyInterface {
  id: ID! @id
}

extend type SomeNode @auth(rules: [{isAuthenticated: true}])

extend type OtherNode @auth(rules: [{isAuthenticated: true}])
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{
  "enableRegex": true
}
----
== should have correct ordering of auth validate checks with nested interfaces

.GraphQL-Query
[source,graphql]
----
{
  someNodes {
    id
    other {
      interfaceField {
        id
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "auth": {
    "isAuthenticated": true,
    "roles": [],
    "jwt": {
      "roles": []
    }
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:`SomeNode`)
WHERE apoc.util.validatePredicate(NOT (apoc.util.validatePredicate(NOT ($auth.isAuthenticated = true), "@neo4j/graphql/UNAUTHENTICATED", [0])), "@neo4j/graphql/FORBIDDEN", [0])

CALL {
    WITH this
    MATCH (this)-[this0:HAS_OTHER_NODES]->(this_other:`OtherNode`)
    WHERE apoc.util.validatePredicate(NOT (apoc.util.validatePredicate(NOT ($auth.isAuthenticated = true), "@neo4j/graphql/UNAUTHENTICATED", [0])), "@neo4j/graphql/FORBIDDEN", [0])
    WITH *
    CALL {
        WITH this_other
        MATCH (this_other)-[this1:HAS_INTERFACE_NODES]->(this_other_SomeNode:`SomeNode`)
        WHERE apoc.util.validatePredicate(NOT (apoc.util.validatePredicate(NOT ($auth.isAuthenticated = true), "@neo4j/graphql/UNAUTHENTICATED", [0])), "@neo4j/graphql/FORBIDDEN", [0])
        
        RETURN { __resolveType: "SomeNode", id: this_other_SomeNode.id } AS this_other_interfaceField
        UNION
        WITH this_other
        MATCH (this_other)-[this2:HAS_INTERFACE_NODES]->(this_other_MyImplementation:`MyImplementation`)
        
        RETURN { __resolveType: "MyImplementation", id: this_other_MyImplementation.id } AS this_other_interfaceField
    }
    WITH this_other { interfaceField: this_other_interfaceField } AS this_other
    RETURN head(collect(this_other)) AS this_other
}
RETURN this { .id, other: this_other } AS this
----

'''

