:toc:

= Cypher Union

== Source schema

[source,graphql,schema=true]
----
union Search = Movie | Genre

type Genre @auth(rules: [{operations: [READ], allow: {name: "$jwt.jwtAllowedNamesExample"}}]) {
  name: String
}

type Movie {
  title: String
  search: [Search!]! @relationship(type: "SEARCH", direction: OUT)
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{
  "enableRegex": true
}
----
== Connect Unions (in create)

.GraphQL-Query
[source,graphql]
----
mutation {
  createMovies(
    input: [{title: "some movie", search: {Genre: {connect: [{where: {node: {name: "some genre"}}}]}}}]
  ) {
    movies {
      title
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "this0_title": "some movie",
  "this0_search_Genre_connect0_node_param0": "some genre",
  "resolvedCallbacks": {}
}
----

.Expected Cypher output
[source,cypher]
----
CALL {
CREATE (this0:Movie)
SET this0.title = $this0_title
WITH this0
CALL {
	WITH this0
	OPTIONAL MATCH (this0_search_Genre_connect0_node:Genre)
	WHERE this0_search_Genre_connect0_node.name = $this0_search_Genre_connect0_node_param0
	CALL {
		WITH *
		WITH collect(this0_search_Genre_connect0_node) as connectedNodes, collect(this0) as parentNodes
		CALL {
			WITH connectedNodes, parentNodes
			UNWIND parentNodes as this0
			UNWIND connectedNodes as this0_search_Genre_connect0_node
			MERGE (this0)-[:SEARCH]->(this0_search_Genre_connect0_node)
			RETURN count(*) AS _
		}
		RETURN count(*) AS _
	}
WITH this0, this0_search_Genre_connect0_node
	RETURN count(*) AS connect_this0_search_Genre_connect_Genre
}
RETURN this0
}


RETURN [
this0 { .title }] AS data
----

'''

== Connect Unions (in update)

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(
    where: {title: "some movie"}
    connect: {search: {Genre: {where: {node: {name: "some genre"}}}}}
  ) {
    movies {
      title
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "some movie",
  "this_connect_search_Genre0_node_param0": "some genre",
  "resolvedCallbacks": {}
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:`Movie`)
WHERE this.title = $param0
WITH this
CALL {
	WITH this
	OPTIONAL MATCH (this_connect_search_Genre0_node:Genre)
	WHERE this_connect_search_Genre0_node.name = $this_connect_search_Genre0_node_param0
	CALL {
		WITH *
		WITH collect(this_connect_search_Genre0_node) as connectedNodes, collect(this) as parentNodes
		CALL {
			WITH connectedNodes, parentNodes
			UNWIND parentNodes as this
			UNWIND connectedNodes as this_connect_search_Genre0_node
			MERGE (this)-[:SEARCH]->(this_connect_search_Genre0_node)
			RETURN count(*) AS _
		}
		RETURN count(*) AS _
	}
WITH this, this_connect_search_Genre0_node
	RETURN count(*) AS connect_this_connect_search_Genre_Genre
}
WITH *
RETURN collect(DISTINCT this { .title }) AS data
----

'''

== Create Unions from create mutation

.GraphQL-Query
[source,graphql]
----
mutation {
  createMovies(
    input: [{title: "some movie", search: {Genre: {create: [{node: {name: "some genre"}}]}}}]
  ) {
    movies {
      title
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "this0_title": "some movie",
  "this0_search_Genre0_node_name": "some genre",
  "resolvedCallbacks": {}
}
----

.Expected Cypher output
[source,cypher]
----
CALL {
CREATE (this0:Movie)
SET this0.title = $this0_title

WITH this0
CREATE (this0_search_Genre0_node:Genre)
SET this0_search_Genre0_node.name = $this0_search_Genre0_node_name
MERGE (this0)-[:SEARCH]->(this0_search_Genre0_node)
RETURN this0
}


RETURN [
this0 { .title }] AS data
----

'''

== Create Unions from update create(top-level)

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(create: {search: {Genre: [{node: {name: "some genre"}}]}}) {
    movies {
      title
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "this_create_search_Genre0_node_name": "some genre",
  "resolvedCallbacks": {}
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:`Movie`)
CREATE (this_create_search_Genre0_node:Genre)
SET this_create_search_Genre0_node.name = $this_create_search_Genre0_node_name
MERGE (this)-[:SEARCH]->(this_create_search_Genre0_node)
WITH *
RETURN collect(DISTINCT this { .title }) AS data
----

'''

== Delete Unions (from update)

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(
    where: {title: "some movie"}
    delete: {search: {Genre: {where: {node: {name: "some genre"}}}}}
  ) {
    movies {
      title
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "some movie",
  "updateMovies_args_delete_search_Genre0_where_Genreparam0": "some genre",
  "updateMovies": {
    "args": {
      "delete": {
        "search": {
          "Genre": [
            {
              "where": {
                "node": {
                  "name": "some genre"
                }
              }
            }
          ]
        }
      }
    }
  },
  "resolvedCallbacks": {}
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:`Movie`)
WHERE this.title = $param0
WITH this
OPTIONAL MATCH (this)-[this_delete_search_Genre0_relationship:SEARCH]->(this_delete_search_Genre0:Genre)
WHERE this_delete_search_Genre0.name = $updateMovies_args_delete_search_Genre0_where_Genreparam0
WITH this, collect(DISTINCT this_delete_search_Genre0) AS this_delete_search_Genre0_to_delete
CALL {
	WITH this_delete_search_Genre0_to_delete
	UNWIND this_delete_search_Genre0_to_delete AS x
	DETACH DELETE x
	RETURN count(*) AS _
}
WITH *
RETURN collect(DISTINCT this { .title }) AS data
----

'''

== Disconnect Unions

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(
    where: {title: "some movie"}
    disconnect: {search: {Genre: {where: {node: {name: "some genre"}}}}}
  ) {
    movies {
      title
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "some movie",
  "updateMovies_args_disconnect_search_Genre0_where_Genreparam0": "some genre",
  "updateMovies": {
    "args": {
      "disconnect": {
        "search": {
          "Genre": [
            {
              "where": {
                "node": {
                  "name": "some genre"
                }
              }
            }
          ]
        }
      }
    }
  },
  "resolvedCallbacks": {}
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:`Movie`)
WHERE this.title = $param0
WITH this
CALL {
WITH this
OPTIONAL MATCH (this)-[this_disconnect_search_Genre0_rel:SEARCH]->(this_disconnect_search_Genre0:Genre)
WHERE this_disconnect_search_Genre0.name = $updateMovies_args_disconnect_search_Genre0_where_Genreparam0
CALL {
	WITH this_disconnect_search_Genre0, this_disconnect_search_Genre0_rel, this
	WITH collect(this_disconnect_search_Genre0) as this_disconnect_search_Genre0, this_disconnect_search_Genre0_rel, this
	UNWIND this_disconnect_search_Genre0 as x
	DELETE this_disconnect_search_Genre0_rel
	RETURN count(*) AS _
}
RETURN count(*) AS disconnect_this_disconnect_search_Genre_Genre
}
WITH *
RETURN collect(DISTINCT this { .title }) AS data
----

'''

== Disconnect Unions (in update)

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(
    where: {title: "some movie"}
    update: {search: {Genre: {disconnect: [{where: {node: {name: "some genre"}}}]}}}
  ) {
    movies {
      title
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "some movie",
  "updateMovies_args_update_search_Genre0_disconnect0_where_Genreparam0": "some genre",
  "updateMovies": {
    "args": {
      "update": {
        "search": {
          "Genre": [
            {
              "disconnect": [
                {
                  "where": {
                    "node": {
                      "name": "some genre"
                    }
                  }
                }
              ]
            }
          ]
        }
      }
    }
  },
  "resolvedCallbacks": {}
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:`Movie`)
WHERE this.title = $param0


WITH this
CALL {
WITH this
OPTIONAL MATCH (this)-[this_search_Genre0_disconnect0_rel:SEARCH]->(this_search_Genre0_disconnect0:Genre)
WHERE this_search_Genre0_disconnect0.name = $updateMovies_args_update_search_Genre0_disconnect0_where_Genreparam0
CALL {
	WITH this_search_Genre0_disconnect0, this_search_Genre0_disconnect0_rel, this
	WITH collect(this_search_Genre0_disconnect0) as this_search_Genre0_disconnect0, this_search_Genre0_disconnect0_rel, this
	UNWIND this_search_Genre0_disconnect0 as x
	DELETE this_search_Genre0_disconnect0_rel
	RETURN count(*) AS _
}
RETURN count(*) AS disconnect_this_search_Genre0_disconnect_Genre
}

RETURN collect(DISTINCT this { .title }) AS data
----

'''

== Read Unions simple

.GraphQL-Query
[source,graphql]
----
{
  movies {
    search {
      ... on Movie {
        title
      }
      ... on Genre {
        name
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "Horror"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:`Movie`)

CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:SEARCH]->(this_search:`Genre`)
        WHERE apoc.util.validatePredicate(NOT ((this_search.name IS NOT NULL AND this_search.name = $param0)), "@neo4j/graphql/FORBIDDEN", [0])
        WITH this_search  { __resolveType: "Genre",  .name } AS this_search
        RETURN this_search AS this_search
        UNION
        WITH *
        MATCH (this)-[this1:SEARCH]->(this_search:`Movie`)
        WITH this_search  { __resolveType: "Movie",  .title } AS this_search
        RETURN this_search AS this_search
    }
    WITH this_search
    RETURN collect(this_search) AS this_search
}
RETURN this { search: this_search } AS this
----

'''

== Read Unions with filter and limit

.GraphQL-Query
[source,graphql]
----
{
  movies(where: {title: "some title"}) {
    search(
      where: {Movie: {title: "The Matrix"}, Genre: {name: "Horror"}}
      options: {offset: 1, limit: 10}
    ) {
      ... on Movie {
        title
      }
      ... on Genre {
        name
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "some title",
  "param1": "Horror",
  "param2": "Horror",
  "param3": "The Matrix",
  "param4": {
    "low": 1,
    "high": 0
  },
  "param5": {
    "low": 10,
    "high": 0
  }
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:`Movie`)
WHERE this.title = $param0

CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:SEARCH]->(this_search:`Genre`)
        WHERE (this_search.name = $param1 AND apoc.util.validatePredicate(NOT ((this_search.name IS NOT NULL AND this_search.name = $param2)), "@neo4j/graphql/FORBIDDEN", [0]))
        WITH this_search  { __resolveType: "Genre",  .name } AS this_search
        RETURN this_search AS this_search
        UNION
        WITH *
        MATCH (this)-[this1:SEARCH]->(this_search:`Movie`)
        WHERE this_search.title = $param3
        WITH this_search  { __resolveType: "Movie",  .title } AS this_search
        RETURN this_search AS this_search
    }
    WITH this_search
    
    SKIP $param4
    LIMIT $param5
    RETURN collect(this_search) AS this_search
}
RETURN this { search: this_search } AS this
----

'''

== Read Unions with missing types

.GraphQL-Query
[source,graphql]
----
{
  movies {
    search {
      ... on Genre {
        name
      }
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "Horror"
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:`Movie`)

CALL {
    WITH this
    CALL {
        WITH *
        MATCH (this)-[this0:SEARCH]->(this_search:`Genre`)
        WHERE apoc.util.validatePredicate(NOT ((this_search.name IS NOT NULL AND this_search.name = $param0)), "@neo4j/graphql/FORBIDDEN", [0])
        WITH this_search  { __resolveType: "Genre",  .name } AS this_search
        RETURN this_search AS this_search
        UNION
        WITH *
        MATCH (this)-[this1:SEARCH]->(this_search:`Movie`)
        WITH this_search { __resolveType: "Movie" } AS this_search
        RETURN this_search AS this_search
    }
    WITH this_search
    RETURN collect(this_search) AS this_search
}
RETURN this { search: this_search } AS this
----

'''

== Update Unions

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(
    where: {title: "some movie"}
    update: {search: {Genre: {where: {node: {name: "some genre"}}, update: {node: {name: "some new genre"}}}}}
  ) {
    movies {
      title
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0": "some movie",
  "updateMovies_args_update_search_Genre0_where_Genreparam0": "some genre",
  "this_update_search_Genre0_name": "some new genre",
  "auth": {
    "isAuthenticated": true,
    "roles": [],
    "jwt": {
      "roles": []
    }
  },
  "updateMovies": {
    "args": {
      "update": {
        "search": {
          "Genre": [
            {
              "where": {
                "node": {
                  "name": "some genre"
                }
              },
              "update": {
                "node": {
                  "name": "some new genre"
                }
              }
            }
          ]
        }
      }
    }
  },
  "resolvedCallbacks": {}
}
----

.Expected Cypher output
[source,cypher]
----
MATCH (this:`Movie`)
WHERE this.title = $param0


WITH this
OPTIONAL MATCH (this)-[this_search0_relationship:SEARCH]->(this_search_Genre0:Genre)
WHERE this_search_Genre0.name = $updateMovies_args_update_search_Genre0_where_Genreparam0
CALL apoc.do.when(this_search_Genre0 IS NOT NULL, "


SET this_search_Genre0.name = $this_update_search_Genre0_name

RETURN count(*) AS _
", "", {this:this, updateMovies: $updateMovies, this_search_Genre0:this_search_Genre0, auth:$auth,this_update_search_Genre0_name:$this_update_search_Genre0_name})
YIELD value AS _

RETURN collect(DISTINCT this { .title }) AS data
----

'''

