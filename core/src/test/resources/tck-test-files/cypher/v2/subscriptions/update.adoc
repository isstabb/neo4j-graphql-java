:toc:

= Subscriptions metadata on update

== Source schema

[source,graphql,schema=true]
----
type Actor {
  name: String!
  movies: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT)
}

type Movie {
  id: ID!
  actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN)
}
----

== Configuration

.Configuration
[source,json,schema-config=true]
----
{
  "enableRegex": true
}
----
== Simple update with subscriptions

.GraphQL-Query
[source,graphql]
----
mutation {
  updateMovies(where: {id: "1"}, update: {id: "2"}) {
    movies {
      id
    }
  }
}
----

.Expected Cypher params
[source,json]
----
{
  "param0" : "1",
  "resolvedCallbacks" : { },
  "this_update_id" : "2"
}
----

.Expected Cypher output
[source,cypher]
----
WITH [] AS meta
MATCH (this:Movie)
WHERE this.id = $param0
WITH this {
	.*
} AS oldProps, this, meta
CALL {
	WITH *
	SET this.id = $this_update_id
	RETURN meta AS update_meta
}
WITH *, update_meta AS meta
WITH this, (meta + {
	event: 'update',
	id: id(this),
	properties: {
		old: oldProps,
		new: this {
			.*
		}
	},
	timestamp: timestamp(),
	typename: 'Movie'
}) AS meta
WITH *
UNWIND CASE meta WHEN [] THEN [NULL] ELSE meta END AS m
RETURN collect(DISTINCT this {
	.id
}) AS data, collect(DISTINCT m) AS meta
----

'''

