:toc:

= @exclude directive -> can be used to skip generation of Mutation

== Source schema

[source,graphql,schema=true]
----
type Actor @exclude(operations: [CREATE]) {
  name: String
}
----

== Augmented schema

.Augmented Schema
[source,graphql]
----
schema {
  query: Query
  mutation: Mutation
}

type Actor {
  name: String
}

type ActorAggregateSelection {
  count: Int!
  name: StringAggregateSelectionNullable!
}

type ActorEdge {
  cursor: String!
  node: Actor!
}

type ActorsConnection {
  edges: [ActorEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type DeleteInfo {
  bookmark: String
  nodesDeleted: Int!
  relationshipsDeleted: Int!
}

type Mutation {
  deleteActors(where: ActorWhere): DeleteInfo!
  updateActors(update: ActorUpdateInput, where: ActorWhere): UpdateActorsMutationResponse!
}

"Pagination information (Relay)"
type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Query {
  actors(options: ActorOptions, where: ActorWhere): [Actor!]!
  actorsAggregate(where: ActorWhere): ActorAggregateSelection!
  actorsConnection(after: String, first: Int, sort: [ActorSort], where: ActorWhere): ActorsConnection!
}

type StringAggregateSelectionNullable {
  longest: String
  shortest: String
}

type UpdateActorsMutationResponse {
  actors: [Actor!]!
  info: UpdateInfo!
}

type UpdateInfo {
  bookmark: String
  nodesCreated: Int!
  nodesDeleted: Int!
  relationshipsCreated: Int!
  relationshipsDeleted: Int!
}

enum SortDirection {
  "Sort by field values in ascending order."
  ASC
  "Sort by field values in descending order."
  DESC
}

input ActorOptions {
  limit: Int
  offset: Int
  "Specify one or more ActorSort objects to sort Actors by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [ActorSort!]
}

"Fields to sort Actors by. The order in which sorts are applied is not guaranteed when specifying many fields in one ActorSort object."
input ActorSort {
  name: SortDirection
}

input ActorUpdateInput {
  name: String
}

input ActorWhere {
  AND: [ActorWhere!]
  OR: [ActorWhere!]
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
}

----

'''
